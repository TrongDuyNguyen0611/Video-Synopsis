import numpy as np

from typing import List
from pcgvs.extraction import Tube
from pcgvs.aggregation.relations import Intersection, Overlapping, RelationsMap


class Node: 

    def __init__(self, id: str, tube: Tube, frame=None):
        self.id = id
        self.tube = tube
        self.color = None 
        self.frame = frame

    def is_mainnode(self) -> bool: 
        return self.frame is None

    def is_subnode(self) -> bool:
        return self.frame is not None

#---------------------------------------#
#---------------------------------------#
#---------------------------------------#


class PCG:
    """ This is (kind of) the potential collision graph described in He Et al.
        A peculiarity of this implementation is that the nodes have a particular
        nomenclature that helps moving around the graph:
        - m-node generated from tube T1 is named T1
        - s-node generated from tube T1 intersecting with T2 is named T1-T2
        - s-node (start) generated from tube T1 overlapping with T2 is named T1-T2-s
        - s-node (end) generated from tube T1 overlapping with T2 is named T1-T2-e
        Given a subnode involved in an overlapping relation, we can instantly identify
        all four protagonists of the overlapping relation. 
    """    
    
    def __init__(self, tubes: List[Tube], relations: RelationsMap):
        self.tubes = tubes
        self.relations = relations
        self.nodes = {}
        self.edges = []
        self.A = {}
        self._compute_graph()
        self._compute_adjacency_matrix()


    def _compute_graph(self):
        """ Perform the node and edges generation process
            described in He Et al.  
        """
        self.edges = []
        rmap = self.relations.as_dict()
    
        for tube in self.tubes:
            tube_relations = rmap[tube.tag]
            
            if self._generates_isolated_main_node(tube_relations):
                self.nodes[str(tube.tag)] = Node(tube.tag, tube)
                continue
            
            # If we arrive here, then our tube collide with some other tube,
            # hence, we must build an s-node for each potential collision. 
            
            for tag, relation in tube_relations.items():
                if tag == tube.tag or relation is None: continue
                    
                if type(relation) is Overlapping:
                    vs = f'{tube.tag}-{tag}-s'
                    ve = f'{tube.tag}-{tag}-e'
                    self.nodes[vs] = Node(vs, tube, relation.sframe)
                    self.nodes[ve] = Node(ve, tube, relation.eframe)
                    
                    # Insert the direct edge between the nodes 
                    weight = relation.eframe - relation.sframe
                    self._insert_edge_nodup(vs, ve, weight)
                    
                    # Insert undirected edges with colliding tube
                    us = f'{tag}-{tube.tag}-s'
                    ue = f'{tag}-{tube.tag}-e'
                    self._insert_edge_nodup(vs, us, -1)
                    self._insert_edge_nodup(us, vs, -1)
                    self._insert_edge_nodup(ve, ue, -1)
                    self._insert_edge_nodup(ue, ve, -1)
                    
                elif type(relation) is Intersection:
                    v = f'{tube.tag}-{tag}'
                    self.nodes[v] = Node(v, tube, relation.frame)
                    # add an edge in both directions 
                    u = f'{tag}-{tube.tag}'
                    self._insert_edge_nodup(u, v, 1)
                    self._insert_edge_nodup(v, u, 1)
                                

    def _compute_adjacency_matrix(self):
        for v in self.nodes:
            self.A[v] = {}
            for u in self.nodes:
                self.A[v][u] = 0        
        for v, u, w in self.edges:
            self.A[v][u] = w


    def _generates_isolated_main_node(self, tube_relations):
        """ If the tube has irrilevant relations with all 
            other tubes, then it can be abstracted as an isolated
            main-node.
        """
        return all([ r is None for r in tube_relations.values() ])


    def _insert_edge_nodup(self, fr, to, w):
        if ((fr, to, w) in self.edges): return
        self.edges.append((fr, to, w))


    def uncolored_nodes(self) -> List[str]:
        return [ k for k, v in self.nodes.items() if v.color is None ]
    

    def node(self, key) -> Node:
        return self.nodes[key]

    
    def isolated_main_node(self, key: str) -> bool:
        return len(key.split('-')) == 1


    def generated_by_intersection(self, key: str) -> bool:
        return len(key.split('-')) == 2
    

    def generated_by_overlapping(self, key:str) -> bool:
        return len(key.split('-')) == 3    
    

    def identify_quatern(self, key) -> tuple:
        """ Given a subnode generated by an overlapping, returns (vs, ve, vsp, vep) where:
            - vs is the node corresponding to the overlapping start in the tube of key
            - ve is the node corresponding to the overlapping end in the tube of key
            - vsp is the node corresponding to the overlapping start in the other tube
            - vep is the node corresponding to the overlapping end in the other tube
        """
        if self.generated_by_intersection(key): 
            raise Exception('cannot identify quatern on intersection generated subnodes.')
        fr, to, _ = key.split('-')
        vs  = f'{fr}-{to}-s'
        ve  = f'{fr}-{to}-e'
        vsp = f'{to}-{fr}-s'
        vep = f'{to}-{fr}-e'
        return vs, ve, vsp, vep


    def identify_opposite(self, key:str) -> str:
        """ Given a subnode generated by overlapping, returns the opposite node.
            If the node is the starting one, the method returns the ending one, and viceversa.
        """
        if self.generated_by_intersection(key): 
            raise Exception('cannot identify opposite on intersection generated subnodes.')
        ex = 'e' if key[-1] == 's' else 's' 
        return key[:-1] + ex
        
    
    def adjacents(self, key) -> List[str]:
        if key not in self.nodes: return None
        return [ (k, v) for k, v in self.nodes.items() if self.A[key][k] != 0 ]
        
    
    def clean_colors(self):
        for v in self.nodes.values():
            v.color = None
